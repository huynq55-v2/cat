QEMU
 â””â”€â”€ OVMF (EDK2 UEFI firmware)
      â””â”€â”€ BOOTX64.EFI   â† báº¡n viáº¿t báº±ng Rust
           â”œâ”€â”€ Load kernel ELF
           â”œâ”€â”€ Setup paging (higher-half)
           â”œâ”€â”€ Build BootInfo
           â”œâ”€â”€ ExitBootServices
           â””â”€â”€ jump kernel_entry(bootinfo)
===============================================================================
Stack alignment (cÄƒn chá»‰nh stack)

Stack lÃ  vÃ¹ng bá»™ nhá»› lÆ°u dá»¯ liá»‡u táº¡m thá»i khi gá»i hÃ m (local variables, return addresses,â€¦)

Stack alignment = Ä‘áº£m báº£o con trá» stack (RSP) chia háº¿t cho 16 bytes trÆ°á»›c khi gá»i hÃ m

VÃ¬ sao?

CPU SIMD / SSE yÃªu cáº§u stack 16-byte aligned Ä‘á»ƒ hoáº¡t Ä‘á»™ng á»•n Ä‘á»‹nh

Rust / C / SysV64 ABI tuÃ¢n theo quy táº¯c nÃ y

VÃ­ dá»¥ lá»—i stack misalignment:

Khi dÃ¹ng SSE / AVX trÃªn stack khÃ´ng 16-byte aligned â†’ crash
===============================================================================
Trong Rust, unwrap() lÃ  má»™t method Ä‘Æ°á»£c dÃ¹ng vá»›i cÃ¡c kiá»ƒu Option<T> hoáº·c Result<T, E> Ä‘á»ƒ láº¥y giÃ¡ trá»‹ bÃªn trong.

1ï¸âƒ£ Vá»›i Option<T>

Option<T> cÃ³ hai giÃ¡ trá»‹:

enum Option<T> {
    Some(T),
    None,
}


Some(x) â†’ cÃ³ giÃ¡ trá»‹ x

None â†’ khÃ´ng cÃ³ giÃ¡ trá»‹

VÃ­ dá»¥:

let maybe_number: Option<i32> = Some(42);
let n = maybe_number.unwrap(); // n = 42


Náº¿u lÃ  None thÃ¬ unwrap() panic, dá»«ng chÆ°Æ¡ng trÃ¬nh:

let maybe_number: Option<i32> = None;
let n = maybe_number.unwrap(); // panic: called `Option::unwrap()` on a `None` value

2ï¸âƒ£ Vá»›i Result<T, E>

Result<T, E> dÃ¹ng Ä‘á»ƒ xá»­ lÃ½ lá»—i:

enum Result<T, E> {
    Ok(T),
    Err(E),
}


Ok(x) â†’ thÃ nh cÃ´ng, giÃ¡ trá»‹ lÃ  x

Err(e) â†’ tháº¥t báº¡i, giÃ¡ trá»‹ lá»—i lÃ  e

fn divide(a: i32, b: i32) -> Result<i32, &'static str> {
    if b == 0 { Err("divide by zero") } else { Ok(a / b) }
}

let res = divide(10, 2).unwrap(); // 5
let res = divide(10, 0).unwrap(); // panic: "divide by zero"

âš ï¸ LÆ°u Ã½

unwrap() dá»… panic, nÃªn chá»‰ dÃ¹ng khi cháº¯c cháº¯n cÃ³ giÃ¡ trá»‹.

Thay tháº¿ an toÃ n:

match:

match maybe_number {
    Some(n) => println!("Number = {}", n),
    None => println!("No value"),
}


unwrap_or(default) â†’ láº¥y giÃ¡ trá»‹ hoáº·c dÃ¹ng máº·c Ä‘á»‹nh náº¿u None / Err

expect("message") â†’ nhÆ° unwrap nhÆ°ng cÃ³ thÃ´ng bÃ¡o lá»—i rÃµ rÃ ng
===============================================================================
Build commands:
cargo +nightly uefi_boot --release
cargo +nightly kernel --release
===============================================================================
Install QEMU OVMF (UEFI firmware):
sudo apt install ovmf
===============================================================================
Náº¿u vÃ­ Kernel nhÆ° má»™t tÃ²a nhÃ  an ninh cao:

    GDT lÃ  há»‡ thá»‘ng phÃ¢n quyá»n (tháº» nhÃ¢n viÃªn, tháº» khÃ¡ch, tháº» giÃ¡m Ä‘á»‘c).

    TSS lÃ  lá»‘i thoÃ¡t hiá»ƒm kháº©n cáº¥p khi cÃ³ sá»± cá»‘ chÃ¡y ná»• (Stack Overflow).

DÆ°á»›i Ä‘Ã¢y lÃ  giáº£i thÃ­ch chi tiáº¿t vÃ  cÃ¡ch hiá»‡n thá»±c.
1. KhÃ¡i niá»‡m & Táº¡i sao chÃºng cáº§n thiáº¿t?
A. GDT (Global Descriptor Table)

Trong cháº¿ Ä‘á»™ 64-bit (Long Mode), CPU khÃ´ng cÃ²n dÃ¹ng GDT Ä‘á»ƒ quáº£n lÃ½ bá»™ nhá»› (Segmentation) theo kiá»ƒu cÅ© (Base/Limit) ná»¯a vÃ¬ chÃºng ta Ä‘Ã£ dÃ¹ng Paging. Tuy nhiÃªn, GDT váº«n báº¯t buá»™c tá»“n táº¡i vÃ¬ 2 lÃ½ do:

    PhÃ¢n quyá»n (Privilege Levels): CPU cáº§n GDT Ä‘á»ƒ biáº¿t Ä‘oáº¡n code nÃ o cháº¡y á»Ÿ Kernel Mode (Ring 0) vÃ  Ä‘oáº¡n code nÃ o cháº¡y á»Ÿ User Mode (Ring 3).

    Load TSS: GDT chá»©a má»™t má»¥c Ä‘áº·c biá»‡t trá» Ä‘áº¿n TSS. KhÃ´ng cÃ³ GDT, CPU khÃ´ng tÃ¬m tháº¥y TSS.

B. TSS (Task State Segment)

Trong quÃ¡ khá»©, TSS dÃ¹ng Ä‘á»ƒ lÆ°u tráº¡ng thÃ¡i cÃ¡c tiáº¿n trÃ¬nh (Hardware Task Switching), nhÆ°ng cÃ¡ch nÃ y quÃ¡ cháº­m nÃªn Ä‘Ã£ bá»‹ bá». Trong 64-bit, TSS chá»‰ cÃ²n má»™t nhiá»‡m vá»¥ sinh tá»­: Chá»©a cÃ¡c Stack Pointer (NgÄƒn xáº¿p) dá»± phÃ²ng.

Váº¥n Ä‘á» "GÃ  vÃ  Trá»©ng" (Stack Overflow):

    Giáº£ sá»­ Kernel Stack bá»‹ trÃ n (Stack Overflow).

    CPU phÃ¡t hiá»‡n lá»—i, nÃ³ muá»‘n gá»i hÃ m xá»­ lÃ½ lá»—i (Exception Handler).

    Äá»ƒ gá»i hÃ m, CPU cáº§n Ä‘áº©y (push) Ä‘á»‹a chá»‰ quay vá» vÃ o Stack.

    NhÆ°ng Stack Ä‘ang Ä‘áº§y! CPU khÃ´ng push Ä‘Æ°á»£c -> Sinh ra lá»—i Double Fault.

    CPU láº¡i cá»‘ push Double Fault vÃ o Stack -> Váº«n Ä‘áº§y -> Triple Fault -> Restart mÃ¡y.

Giáº£i phÃ¡p (IST - Interrupt Stack Table): TSS cho phÃ©p báº¡n khai bÃ¡o 7 cÃ¡i ngÄƒn xáº¿p "sÆ¡ cua" (IST). Khi cÃ³ lá»—i nghiÃªm trá»ng (nhÆ° Double Fault), CPU sáº½ tá»± Ä‘á»™ng nháº£y sang Stack sÆ¡ cua nÃ y Ä‘á»ƒ xá»­ lÃ½, thay vÃ¬ dÃ¹ng Stack cÅ© Ä‘ang bá»‹ há»ng.
2. Cáº§n nhá»¯ng gÃ¬ Ä‘á»ƒ Implement?

Báº¡n khÃ´ng cáº§n viáº¿t thá»§ cÃ´ng tá»«ng bit, vÃ¬ thÆ° viá»‡n x86_64 mÃ  báº¡n Ä‘ang dÃ¹ng Ä‘Ã£ há»— trá»£ táº­n rÄƒng cÃ¡c struct nÃ y.

CÃ¡c bÆ°á»›c thá»±c hiá»‡n:

    Táº¡o TSS: Khai bÃ¡o má»™t IST stack riÃªng cho Double Fault.

    Táº¡o GDT: ThÃªm Kernel Code Segment, Kernel Data Segment vÃ  TSS Segment vÃ o Ä‘Ã³.

    Lazy Static: VÃ¬ GDT vÃ  TSS pháº£i tá»“n táº¡i suá»‘t Ä‘á»i chÆ°Æ¡ng trÃ¬nh, chÃºng ta dÃ¹ng lazy_static Ä‘á»ƒ khá»Ÿi táº¡o chÃºng.

    Load: DÃ¹ng lá»‡nh assembly (qua wrapper cá»§a Rust) Ä‘á»ƒ náº¡p GDT vÃ  TSS vÃ o thanh ghi CPU.
===============================================================================
Check format code: cargo check va cargo clippy
===============================================================================
THE HOBBY KERNEL MANIFESTO
ğŸ’€ PART I: PANIC & LOG OR DIE TRYING

1. Táº¡i sao Kernel Hobby pháº£i Panic? Linux cÃ³ hÃ ng triá»‡u user, nÃ³ khÃ´ng Ä‘Æ°á»£c phÃ©p sáº­p. Báº¡n chá»‰ cÃ³ 1 user (lÃ  chÃ­nh báº¡n).

    Linux: Cháº¥p nháº­n lá» Ä‘i lá»—i (return -EINVAL) Ä‘á»ƒ giá»¯ uptime.

    Báº¡n: Bug = Sá»± thiáº¿u hiá»ƒu biáº¿t vá» ABI. Náº¿u lá» Ä‘i â†’ Bug lan truyá»n â†’ KhÃ´ng thá»ƒ debug.

    Luáº­t: Panic sá»›m = Cáº¯t nhiá»…m trÃ¹ng.

2. NguyÃªn táº¯c "BiÃªn giá»›i ABI" Báº¥t cá»© thá»© gÃ¬ tá»« User-space nÃ©m vÃ o Kernel Ä‘á»u lÃ  Untrusted.

    Pointer, Struct, Flag, Syscall args â†’ ASSERT / PANIC NGAY Láº¬P Tá»¨C Náº¾U SAI.

    Äá»«ng return -EINVAL. HÃ£y panic("mmap: unsupported flag XYZ").

    Kernel cháº¿t mÃ  cÃ³ thÃ´ng tin > Kernel sá»‘ng mÃ  vÃ´ nghÄ©a.

3. Log Everything Debug ABI mÃ  khÃ´ng log = MÃ² kim Ä‘Ã¡y bá»ƒ. Log pháº£i nhÆ° "Camera an ninh":

    [PID:TID] SYSCALL(args) -> RETURN [errno]

    Log cáº£: VM mappings, Signal, Context switch.

âš–ï¸ PART II: MUSL IS THE LAW

1. Musl lÃ  Oracle

    KhÃ´ng cÃ³ PDF nÃ o chuáº©n hÆ¡n code cá»§a Musl.

    Musl crash â†’ Kernel sai. Äá»«ng Ä‘á»• lá»—i cho Musl.

    Musl khÃ´ng "workaround" lá»—i cá»§a kernel. NÃ³ phÆ¡i bÃ y sá»± tháº­t tráº§n trá»¥i.

2. Quy trÃ¬nh "Thá»­ lá»­a" (The Validation Loop)

    Build static binary vá»›i musl-gcc hoáº·c rustc +crt-static.

    Cháº¡y trÃªn Linux tháº­t + strace -f â†’ LÆ°u láº¡i log chuáº©n.

    Cháº¡y trÃªn Kernel cá»§a báº¡n.

    DIFF HAI LOG ÄÃ“.

ğŸš€ PART III: ROADMAP TO RUST STD

Äá»«ng nháº£y cÃ³c. HÃ£y Ä‘i theo thá»© tá»± nÃ y Ä‘á»ƒ giá»¯ sanity:

    Boot Phase: Paging, IDT, GDT (ChÆ°a cÃ³ user-space).

    Giai Ä‘oáº¡n "CÃ¢m": exit, write. (Hello World).

    Giai Ä‘oáº¡n "Äá»c": read, openat, fstat (ELF loader).

    Giai Ä‘oáº¡n "Bá»™ nhá»›": mmap, brk (Äá»ƒ malloc cháº¡y).

    Giai Ä‘oáº¡n "Identity" (Quan trá»ng cho Rust): arch_prctl, fs.base (TLS setup).

    Giai Ä‘oáº¡n "BÃ¡o lá»—i": rt_sigaction, Signal frame (Äá»ƒ Rust panic in ra stacktrace).

    Giai Ä‘oáº¡n "Äa nhiá»‡m": clone, futex (Rust std hoÃ n chá»‰nh).

    GHI NHá»š: Panic lÃ  la bÃ n. Log lÃ  báº£n Ä‘á»“. Musl lÃ  chÃ¢n lÃ½.
===============================================================================
MANIFESTO: LA BÃ€N VÃ€ Báº¢N Äá»’

"Panic lÃ  la bÃ n, Log lÃ  báº£n Ä‘á»“." ÄÃ¢y khÃ´ng pháº£i triáº¿t lÃ½ sÃ¡o rá»—ng. ÄÃ¢y lÃ  bÃ i há»c Ä‘Æ°á»£c viáº¿t báº±ng hÃ ng trÄƒm giá» debug trong tuyá»‡t vá»ng.
1. Äá»ŠNH NGHÄ¨A Sá»° Sá»NG CÃ’N

LA BÃ€N (PANIC): Sá»° Tá»ª CHá»I TUYá»†T Äá»I Panic khÃ´ng pháº£i lÃ  lá»—i. Panic lÃ  phanh kháº©n cáº¥p. NÃ³ hÃ©t lÃªn: "MÃ y Ä‘ang Ä‘i vÃ o vÃ¹ng Ä‘áº¥t cháº¿t." Khi Kernel gáº·p thá»© nÃ³ khÃ´ng hiá»ƒu (Flag láº¡, Struct sai, Pointer rÃ¡c):

    KHÃ”NG Ä‘oÃ¡n mÃ².

    KHÃ”NG lá» Ä‘i.

    KHÃ”NG return -EINVAL. ğŸ‘‰ PANIC NGAY Láº¬P Tá»¨C. Cháº·n Ä‘á»©ng cÃ¡i sai trÆ°á»›c khi nÃ³ di cÄƒn.

Báº¢N Äá»’ (LOG): Há»˜P ÄEN Cá»¦A MÃY BAY Log khÃ´ng pháº£i tin rÃ¡c. Log lÃ  báº±ng chá»©ng phÃ¡p y. NÃ³ tráº£ lá»i cÃ¢u há»i sinh tá»­: Ai gá»i? Gá»i lÃºc nÃ o? TrÆ°á»›c Ä‘Ã³ Ä‘Ã£ lÃ m gÃ¬? Má»™t dÃ²ng log vÃ´ giÃ¡ trá»‹ ngÃ n vÃ ng: [PID:3] mmap(0, 8k, RW, ANON) -> 0x7f...
2. BI Ká»ŠCH Cá»¦A Sá»° THIáº¾U Há»¤T

    CÃ³ Panic - Máº¥t Log: Báº¡n biáº¿t mÃ¬nh Ä‘Ã£ cháº¿t, nhÆ°ng khÃ´ng biáº¿t ai báº¯n mÃ¬nh. (MÃ¹ lÃ²a).

        Káº¿t quáº£: panic: mmap unsupported. Háº¿t.

    CÃ³ Log - Máº¥t Panic: Báº¡n nhÃ¬n tháº¥y mÃ¬nh lao xuá»‘ng vá»±c, tá»«ng bÆ°á»›c má»™t, nhÆ°ng khÃ´ng phanh láº¡i. (Tá»± sÃ¡t tá»« tá»«).

        Káº¿t quáº£: Kernel váº«n cháº¡y â†’ Bá»™ nhá»› nÃ¡t bÃ©t â†’ Crash ngáº«u nhiÃªn 5 phÃºt sau.

3. LUáº¬T SINH Tá»’N: TRÄ‚NG TRá»I Rá»’I Má»šI CHáº¾T

QUY Táº®C VÃ€NG: Äá»«ng bao giá» Panic trong im láº·ng. HÃ£y ghi láº¡i hiá»‡n trÆ°á»ng trÆ°á»›c khi bÃ³p cÃ².

// 1. Ghi láº¡i hiá»‡n trÆ°á»ng (Báº£n Ä‘á»“)
log("FATAL: mmap called with unsupported flags=%lx at addr=%p", flags, addr);

// 2. Káº¿t liá»…u (La bÃ n)
if (flags & UNSUPPORTED) {
    panic("ABORT: Kernel too dumb to handle this flag");
}

4. PHÃ‚N Cáº¤P Cá»¦A Sá»° SAI Láº¦M

Äá»«ng nháº§m láº«n giá»¯a Lá»—i cá»§a User vÃ  Sá»± ngu dá»‘t cá»§a Kernel.

    LEVEL 1: HARD PANIC (Kernel Dev sai)

        Gáº·p Flag ABI chÆ°a implement? â†’ PANIC.

        Gáº·p Alignment sai quy táº¯c? â†’ PANIC.

        Táº¡i sao? VÃ¬ code cá»§a báº¡n chÆ°a Ä‘á»§ trÃ¬nh Ä‘á»™ xá»­ lÃ½. Thá»«a nháº­n vÃ  sá»­a nÃ³.

    LEVEL 2: SOFT FAIL (User Space sai)

        File descriptor Ä‘Ã³ng rá»“i váº«n gá»i? â†’ return -EINVAL.

        Quyá»n truy cáº­p sai? â†’ return -EACCES.

        Táº¡i sao? ÄÃ¢y lÃ  hÃ nh vi Ä‘Ãºng cá»§a Linux.

5. Lá»œI TUYÃŠN THá»† Cá»¦A KERNEL DEV

    "Log cho báº¡n kÃ½ á»©c. Panic cho báº¡n lÆ°Æ¡ng tÃ¢m."

    Kernel cháº¡y tiáº¿p khÃ´ng cÃ³ nghÄ©a lÃ  Kernel Ä‘Ãºng.

    Kernel Crash sá»›m lÃ  Kernel trung thá»±c.

    Thiáº¿u má»™t trong hai, báº¡n chá»‰ lÃ  káº» má»™ng du trong Ä‘á»‘ng code assembly.

6. Má»†NH Lá»†NH HÃ€NH Äá»˜NG (RIGHT NOW)

Äá»«ng chá» Ä‘á»£i. Ngay bÃ¢y giá»:

    Log má»i Syscall (Entry & Exit).

    Panic má»i Flag báº¡n chÆ°a support.

    Panic má»i Struct báº¡n chÆ°a validate.

    DÃ¹ng musl lÃ m thÆ°á»›c Ä‘o sá»± tháº­t.

ThÃ  Crash Ä‘au Ä‘á»›n má»™t láº§n cÃ²n hÆ¡n cháº¡y sai mÃ£i mÃ£i.
===============================================================================
MINIMAL RUST TEST BINARIES (theo tá»«ng giai Ä‘oáº¡n)
Giai Ä‘oáº¡n 1 â€” chá»‰ exit + write
// hello.rs
fn main() {
    println!("hello");
}


Compile:

rustc hello.rs \
  --target x86_64-unknown-linux-musl \
  -C target-feature=+crt-static


Kernel cáº§n:

write

exit

Giai Ä‘oáº¡n 2 â€” malloc + mmap
fn main() {
    let mut v = Vec::new();
    for i in 0..1000 {
        v.push(i);
    }
    println!("{}", v.len());
}


Kernel cáº§n:

mmap

brk

page fault

Giai Ä‘oáº¡n 3 â€” panic Rust (signal / abort)
fn main() {
    panic!("test panic");
}


Kernel cáº§n:

write

exit

(signal optional, abort OK)

Giai Ä‘oáº¡n 4 â€” TLS (Rust báº¯t Ä‘áº§u khÃ³)
thread_local! {
    static X: u64 = 42;
}

fn main() {
    X.with(|v| println!("{}", v));
}


Kernel cáº§n:

arch_prctl

fs.base

TLS ABI

Giai Ä‘oáº¡n 5 â€” Thread + futex
use std::thread;

fn main() {
    let h = thread::spawn(|| {
        println!("child");
    });
    h.join().unwrap();
}


Kernel cáº§n:

clone

futex